# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name cpp_abm_simulate
NULL

cpp_abm_simulate <- function(startx, starty, timesteps, ndes, nopt, shelter_locs_x, shelter_locs_y, sSiteSize, avoidPoints_x, avoidPoints_y, k_desRange, s_desRange, mu_desDir, k_desDir, destinationTrans, destinationMod, avoidTrans, avoidMod, k_step, s_step, mu_angle, k_angle, rescale, b0_Options, b1_Options, b2_Options, rest_Cycle_A, rest_Cycle_M, rest_Cycle_PHI, rest_Cycle_TAU, addCycles, add_Cycle_A, add_Cycle_M, add_Cycle_PHI, add_Cycle_TAU, shelterMatrix, forageMatrix, moveMatrix, fence_x1, fence_x2, fence_y1, fence_y2, p_cross) {
    .Call('_abmAnimalMovementMES_cpp_abm_simulate', PACKAGE = 'abmAnimalMovementMES', startx, starty, timesteps, ndes, nopt, shelter_locs_x, shelter_locs_y, sSiteSize, avoidPoints_x, avoidPoints_y, k_desRange, s_desRange, mu_desDir, k_desDir, destinationTrans, destinationMod, avoidTrans, avoidMod, k_step, s_step, mu_angle, k_angle, rescale, b0_Options, b1_Options, b2_Options, rest_Cycle_A, rest_Cycle_M, rest_Cycle_PHI, rest_Cycle_TAU, addCycles, add_Cycle_A, add_Cycle_M, add_Cycle_PHI, add_Cycle_TAU, shelterMatrix, forageMatrix, moveMatrix, fence_x1, fence_x2, fence_y1, fence_y2, p_cross)
}

#' Check if a line segment (step option) crosses a fence
#' @name check_intersection
#' @param origin start location
#' @param target target location
#' @param fence_x1 fence segment x start values
#' @param fence_x2 fence segment x end values
#' @param fence_y1 fence segment y start values
#' @param fence_y2 fence segment y end values
#' @return A Boolean of whether any fence is crossed
#' Useful resource: https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/
NULL

cpp_check_intersection <- function(origin, target, fence_x1, fence_x2, fence_y1, fence_y2) {
    .Call('_abmAnimalMovementMES_cpp_check_intersection', PACKAGE = 'abmAnimalMovementMES', origin, target, fence_x1, fence_x2, fence_y1, fence_y2)
}

#' cpp_cycle_draw
#' @name cpp_cycle_draw
#' @param TIME A point in time (defined as a double) during the cycle to draw a value from.
#' @param A A double defining the amplitude of the cycle, calculated as the
#'   difference from M (i.e., half of the overall variation in the cycle from
#'   top to bottom).
#' @param M A double defining the cycle offset from 0 (Midline Statistic Of
#'   Rhythm, a rhythm-adjusted mean).
#' @param PHI A double defining the offset of the cycle (\eqn{\phi}; i.e.,
#'   acrophase). Must be kept proportional to \eqn{\tau} to avoid cycle drift.
#' @param TAU A double defining the cycle frequency (\eqn{\tau}; i.e., period),
#'   where \eqn{\tau} is the difference between peaks.
#' @return A double that is between M+A to M-A, draw from the defined cycle at TIME.
#' @details \eqn{\phi} must remain proportional to \eqn{\tau} if the cycle is to remained
#'   sync with period. If not proportional the cycle with drift.
#' @references Cornelissen, G. (2014). Cosinor-based rhythmometry. Theoretical
#'    Biology and Medical Modelling. 11(16)
#'    https://doi.org/10.1186/1742-4682-11-16
NULL

cpp_cycle_draw <- function(TIME, A, M, PHI, TAU) {
    .Call('_abmAnimalMovementMES_cpp_cycle_draw', PACKAGE = 'abmAnimalMovementMES', TIME, A, M, PHI, TAU)
}

#' cpp_get_values
#' @name cpp_get_values
#' @param MATRIX A numeric matrix that the value will be extracted from.
#' @param XLOCS A vector of x locations.
#' @param YLOCS A vector of y locations.
#' @return A vector of values equal to the length of XLOCS extracted from
#'   MATRIX.
#' @details A simple C++ function to extract a value from a Rcpp::NumericMatrix
#'   using two vectors describing location. Note that the counting begins for x
#'   and y begins at zero.
NULL

cpp_get_values <- function(MATRIX, XLOCS, YLOCS) {
    .Call('_abmAnimalMovementMES_cpp_get_values', PACKAGE = 'abmAnimalMovementMES', MATRIX, XLOCS, YLOCS)
}

#' Get maximum or minimum value
#' @name cpp_max/cpp_min
#' @param x A vector of doubles to have the max/min found.
#' @return The maximum or minimum value in the vector.
NULL

cpp_max <- function(x) {
    .Call('_abmAnimalMovementMES_cpp_max', PACKAGE = 'abmAnimalMovementMES', x)
}

cpp_min <- function(x) {
    .Call('_abmAnimalMovementMES_cpp_min', PACKAGE = 'abmAnimalMovementMES', x)
}

#' @title cpp_sample_options
#' @name cpp_sample_options
#' @description The C++ sample function that takes a vector of weights and
#'   randomly returns an integer of the choice using the Rcpp version of
#'   sample().
#'
#' @param W A vector of weights.
#' @details Very simple wrapper to help handle std::vectors, and pre-normalise
#'   the values provided to avoid issues with negative numbers.
#' @return An integer corresponding to the chosen weight in the initially
#'   provided vector. __NOTE: indexing begins at 0 matching C++ convention__.
NULL

cpp_sample_options <- function(W) {
    .Call('_abmAnimalMovementMES_cpp_sample_options', PACKAGE = 'abmAnimalMovementMES', W)
}

#' @name cpp_vonmises
#' @title cpp_vonmises
#' @description A C++ conversion of the *rvm* function provided by the [CircStats package](https://CRAN.R-project.org/package=CircStats).
#' @param N of values to draw.
#' @param MU The mean of the distribution (\eqn{\mu}).
#' @param KAPPA The concentration of the distribution (\eqn{\kappa}).
#' @return A vector drawn from a von Mises distribution equal in length to N.
#'
#' @references
#' S-plus original by Ulric Lund and R port by Claudio Agostinelli (2018). CircStats: Circular Statistics, from Topics in Circular Statistics (2001). R package version 0.2-6. https://CRAN.R-project.org/package=CircStats
#'
cpp_vonmises <- function(N, MU, KAPPA) {
    .Call('_abmAnimalMovementMES_cpp_vonmises', PACKAGE = 'abmAnimalMovementMES', N, MU, KAPPA)
}

